#!/usr/bin/env python
# coding: utf-8

# 

# In[1]:


"""
Mesa Data Collection Module
===========================

DataCollector is meant to provide a simple, standard way to collect data
generated by a Mesa model. It collects three types of data: model-level data,
agent-level data, and tables.

A DataCollector is instantiated with two dictionaries of reporter names and
associated variable names or functions for each, one for model-level data and
one for agent-level data; a third dictionary provides table names and columns.
Variable names are converted into functions which retrieve attributes of that
name.

When the collect() method is called, each model-level function is called, with
the model as the argument, and the results associated with the relevant
variable. Then the agent-level functions are called on each agent in the model
scheduler.

Additionally, other objects can write directly to tables by passing in an
appropriate dictionary object for a table row.

The DataCollector then stores the data it collects in dictionaries:
    * model_vars maps each reporter to a list of its values
    * tables maps each table to a dictionary, with each column as a key with a
      list as its value.
    * _agent_records maps each model step to a list of each agents id
      and its values.

Finally, DataCollector can create a pandas DataFrame from each collection.

The default DataCollector here makes several assumptions:
    * The model has a schedule object called 'schedule'
    * The schedule has an agent list called agents
    * For collecting agent-level variables, agents must have a unique_id

"""
from functools import partial
import itertools
from operator import attrgetter
import pandas as pd
import types


class DataCollector:
    """Class for collecting data generated by a Mesa model.

    A DataCollector is instantiated with dictionaries of names of model- and
    agent-level variables to collect, associated with attribute names or
    functions which actually collect them. When the collect(...) method is
    called, it collects these attributes and executes these functions one by
    one and stores the results.

    """

    model = None

    def __init__(self, model_reporters=None, agent_reporters=None, tables=None):
        """Instantiate a DataCollector with lists of model and agent reporters.
        Both model_reporters and agent_reporters accept a dictionary mapping a
        variable name to either an attribute name, or a method.
        For example, if there was only one model-level reporter for number of
        agents, it might look like:
            {"agent_count": lambda m: m.schedule.get_agent_count() }
        If there was only one agent-level reporter (e.g. the agent's energy),
        it might look like this:
            {"energy": "energy"}
        or like this:
            {"energy": lambda a: a.energy}

        The tables arg accepts a dictionary mapping names of tables to lists of
        columns. For example, if we want to allow agents to write their age
        when they are destroyed (to keep track of lifespans), it might look
        like:
            {"Lifespan": ["unique_id", "age"]}

        Args:
            model_reporters: Dictionary of reporter names and attributes/funcs
            agent_reporters: Dictionary of reporter names and attributes/funcs.
            tables: Dictionary of table names to lists of column names.

        Notes:
            If you want to pickle your model you must not use lambda functions.
            If your model includes a large number of agents, you should *only*
            use attribute names for the agent reporter, it will be much faster.

            Model reporters can take four types of arguments:
            lambda like above:
            {"agent_count": lambda m: m.schedule.get_agent_count() }
            method with @property decorators
            {"agent_count": schedule.get_agent_count()
            class attributes of model
            {"model_attribute": "model_attribute"}
            functions with parameters that have placed in a list
            {"Model_Function":[function, [param_1, param_2]]}

        """
        self.model_reporters = {}
        self.agent_reporters = {}

        self.model_vars = {}
        self._agent_records = {}
        self.tables = {}

        if model_reporters is not None:
            for name, reporter in model_reporters.items():
                self._new_model_reporter(name, reporter)

        if agent_reporters is not None:
            for name, reporter in agent_reporters.items():
                self._new_agent_reporter(name, reporter)

        if tables is not None:
            for name, columns in tables.items():
                self._new_table(name, columns)

    def _new_model_reporter(self, name, reporter):
        """Add a new model-level reporter to collect.

        Args:
            name: Name of the model-level variable to collect.
            reporter: Attribute string, or function object that returns the
                      variable when given a model instance.
        """
        if type(reporter) is str:
            reporter = partial(self._getattr, reporter)
        self.model_reporters[name] = reporter
        self.model_vars[name] = []

    def _new_agent_reporter(self, name, reporter):
        """Add a new agent-level reporter to collect.

        Args:
            name: Name of the agent-level variable to collect.
            reporter: Attribute string, or function object that returns the
                      variable when given a model instance.

        """
        if type(reporter) is str:
            attribute_name = reporter
            reporter = partial(self._getattr, reporter)
            reporter.attribute_name = attribute_name
        self.agent_reporters[name] = reporter

    def _new_table(self, table_name, table_columns):
        """Add a new table that objects can write to.

        Args:
            table_name: Name of the new table.
            table_columns: List of columns to add to the table.

        """
        new_table = {column: [] for column in table_columns}
        self.tables[table_name] = new_table

    def _record_agents(self, model):
        """Record agents data in a mapping of functions and agents."""
        rep_funcs = self.agent_reporters.values()
        if all([hasattr(rep, "attribute_name") for rep in rep_funcs]):
            prefix = ["model.schedule.steps", "unique_id"]
            attributes = [func.attribute_name for func in rep_funcs]
            get_reports = attrgetter(*prefix + attributes)
        else:

            def get_reports(agent):
                _prefix = (agent.model.schedule.steps, agent.unique_id)
                reports = tuple(rep(agent) for rep in rep_funcs)
                return _prefix + reports

        agent_records = map(get_reports, model.schedule.agents)
        return agent_records

    def _reporter_decorator(self, reporter):
        return reporter()

    def collect(self, model):
        """Collect all the data for the given model object."""
        if self.model_reporters:

            for var, reporter in self.model_reporters.items():
                # Check if Lambda operator
                if isinstance(reporter, types.LambdaType):
                    self.model_vars[var].append(reporter(model))
                # Check if model attribute
                elif isinstance(reporter, partial):
                    self.model_vars[var].append(reporter(model))
                # Check if function with arguments
                elif isinstance(reporter, list):
                    self.model_vars[var].append(reporter[0](*reporter[1]))
                else:
                    self.model_vars[var].append(self._reporter_decorator(reporter))

        if self.agent_reporters:
            agent_records = self._record_agents(model)
            self._agent_records[model.schedule.steps] = list(agent_records)

    def add_table_row(self, table_name, row, ignore_missing=False):
        """Add a row dictionary to a specific table.

        Args:
            table_name: Name of the table to append a row to.
            row: A dictionary of the form {column_name: value...}
            ignore_missing: If True, fill any missing columns with Nones;
                            if False, throw an error if any columns are missing

        """
        if table_name not in self.tables:
            raise Exception("Table does not exist.")

        for column in self.tables[table_name]:
            if column in row:
                self.tables[table_name][column].append(row[column])
            elif ignore_missing:
                self.tables[table_name][column].append(None)
            else:
                raise Exception("Could not insert row with missing column")

    @staticmethod
    def _getattr(name, _object):
        """Turn around arguments of getattr to make it partially callable."""
        return getattr(_object, name, None)

    def get_model_vars_dataframe(self):
        """Create a pandas DataFrame from the model variables.

        The DataFrame has one column for each model variable, and the index is
        (implicitly) the model tick.

        """
        return pd.DataFrame(self.model_vars)

    def get_agent_vars_dataframe(self):
        """Create a pandas DataFrame from the agent variables.

        The DataFrame has one column for each variable, with two additional
        columns for tick and agent_id.

        """
        all_records = itertools.chain.from_iterable(self._agent_records.values())
        rep_names = list(self.agent_reporters)

        df = pd.DataFrame.from_records(
            data=all_records,
            columns=["Step", "AgentID"] + rep_names,
        )
        df = df.set_index(["Step", "AgentID"])
        return df

    def get_table_dataframe(self, table_name):
        """Create a pandas DataFrame from a particular table.

        Args:
            table_name: The name of the table to convert.

        """
        if table_name not in self.tables:
            raise Exception("No such table.")
        return pd.DataFrame(self.tables[table_name])


# In[2]:


"""
Batchrunner
===========
A single class to manage a batch run or parameter sweep of a given model.
"""
import copy
import itertools
import random
from collections import OrderedDict
from functools import partial
from itertools import count, product
from multiprocessing import Pool, cpu_count
from warnings import warn
from typing import (
    Any,
    Counter,
    Dict,
    Iterable,
    List,
    Mapping,
    Optional,
    Tuple,
    Type,
    Union,
)

import pandas as pd
from tqdm import tqdm

from mesa.model import Model


def batch_run(
    model_cls: Type[Model],
    parameters: Mapping[str, Union[Any, Iterable[Any]]],
    # We still retain the Optional[int] because users may set it to None (i.e. use all CPUs)
    number_processes: Optional[int] = 1,
    iterations: int = 1,
    data_collection_period: int = -1,
    max_steps: int = 1000,
    display_progress: bool = True,
) -> List[Dict[str, Any]]:
    """Batch run a mesa model with a set of parameter values.
    Parameters
    ----------
    model_cls : Type[Model]
        The model class to batch-run
    parameters : Mapping[str, Union[Any, Iterable[Any]]],
        Dictionary with model parameters over which to run the model. You can either pass single values or iterables.
    number_processes : int, optional
        Number of processes used, by default 1. Set this to None if you want to use all CPUs.
    iterations : int, optional
        Number of iterations for each parameter combination, by default 1
    data_collection_period : int, optional
        Number of steps after which data gets collected, by default -1 (end of episode)
    max_steps : int, optional
        Maximum number of model steps after which the model halts, by default 1000
    display_progress : bool, optional
        Display batch run process, by default True
    Returns
    -------
    List[Dict[str, Any]]
        [description]
    """

    kwargs_list = _make_model_kwargs(parameters) * iterations
    process_func = partial(
        _model_run_func,
        model_cls,
        max_steps=max_steps,
        data_collection_period=data_collection_period,
    )

    total_iterations = len(kwargs_list)
    run_counter = count()

    results: List[Dict[str, Any]] = []

    with tqdm(total_iterations, disable=not display_progress) as pbar:
        iteration_counter: Counter[Tuple[Any, ...]] = Counter()

        def _fn(paramValues, rawdata):
            iteration_counter[paramValues] += 1
            iteration = iteration_counter[paramValues]
            run_id = next(run_counter)
            data = []
            for run_data in rawdata:
                out = {"RunId": run_id, "iteration": iteration - 1}
                out.update(run_data)
                data.append(out)
            results.extend(data)
            pbar.update()

        if number_processes == 1:
            for kwargs in kwargs_list:
                paramValues, rawdata = process_func(kwargs)
                _fn(paramValues, rawdata)
        else:
            with Pool(number_processes) as p:
                for paramValues, rawdata in p.imap_unordered(process_func, kwargs_list):
                    _fn(paramValues, rawdata)

    return results


def _make_model_kwargs(
    parameters: Mapping[str, Union[Any, Iterable[Any]]]
) -> List[Dict[str, Any]]:
    """Create model kwargs from parameters dictionary.
    Parameters
    ----------
    parameters : Mapping[str, Union[Any, Iterable[Any]]]
        Single or multiple values for each model parameter name
    Returns
    -------
    List[Dict[str, Any]]
        A list of all kwargs combinations.
    """
    parameter_list = []
    for param, values in parameters.items():
        if isinstance(values, str):
            # The values is a single string, so we shouldn't iterate over it.
            all_values = [(param, values)]
        else:
            try:
                all_values = [(param, value) for value in values]
            except TypeError:
                all_values = [(param, values)]
        parameter_list.append(all_values)
    all_kwargs = itertools.product(*parameter_list)
    kwargs_list = [dict(kwargs) for kwargs in all_kwargs]
    return kwargs_list


def _model_run_func(
    model_cls: Type[Model],
    kwargs: Dict[str, Any],
    max_steps: int,
    data_collection_period: int,
) -> Tuple[Tuple[Any, ...], List[Dict[str, Any]]]:
    """Run a single model run and collect model and agent data.
    Parameters
    ----------
    model_cls : Type[Model]
        The model class to batch-run
    kwargs : Dict[str, Any]
        model kwargs used for this run
    max_steps : int
        Maximum number of model steps after which the model halts, by default 1000
    data_collection_period : int
        Number of steps after which data gets collected
    Returns
    -------
    Tuple[Tuple[Any, ...], List[Dict[str, Any]]]
        Return model_data, agent_data from the reporters
    """
    model = model_cls(**kwargs)
    while model.running and model.schedule.steps <= max_steps:
        model.step()

    data = []

    steps = list(range(0, model.schedule.steps, data_collection_period))
    if not steps or steps[-1] != model.schedule.steps - 1:
        steps.append(model.schedule.steps - 1)

    for step in steps:
        model_data, all_agents_data = _collect_data(model, step)

        # If there are agent_reporters, then create an entry for each agent
        if all_agents_data:
            stepdata = [
                {**{"Step": step}, **kwargs, **model_data, **agent_data}
                for agent_data in all_agents_data
            ]
        # If there is only model data, then create a single entry for the step
        else:
            stepdata = [{**{"Step": step}, **kwargs, **model_data}]
        data.extend(stepdata)

    return tuple(kwargs.values()), data


def _collect_data(
    model: Model,
    step: int,
) -> Tuple[Dict[str, Any], List[Dict[str, Any]]]:
    """Collect model and agent data from a model using mesas datacollector."""
    dc = model.datacollector

    model_data = {param: values[step] for param, values in dc.model_vars.items()}

    all_agents_data = []
    raw_agent_data = dc._agent_records.get(step, [])
    for data in raw_agent_data:
        agent_dict = {"AgentID": data[1]}
        agent_dict.update(zip(dc.agent_reporters, data[2:]))
        all_agents_data.append(agent_dict)
    return model_data, all_agents_data


class ParameterError(TypeError):
    MESSAGE = (
        "Parameters must map a name to a value. "
        "These names did not match parameters: {}"
    )

    def __init__(self, bad_names):
        self.bad_names = bad_names

    def __str__(self):
        return self.MESSAGE.format(self.bad_names)


class VariableParameterError(ParameterError):
    MESSAGE = (
        "Variable_parameters must map a name to a sequence of values. "
        "These parameters were given with non-sequence values: {}"
    )


class FixedBatchRunner:
    """This class is instantiated with a model class, and model parameters
    associated with one or more values. It is also instantiated with model and
    agent-level reporters, dictionaries mapping a variable name to a function
    which collects some data from the model or its agents at the end of the run
    and stores it.
    Note that by default, the reporters only collect data at the *end* of the
    run. To get step by step data, simply have a reporter store the model's
    entire DataCollector object.
    """

    def __init__(
        self,
        model_cls,
        parameters_list=None,
        fixed_parameters=None,
        iterations=1,
        max_steps=1000,
        model_reporters=None,
        agent_reporters=None,
        display_progress=True,
    ):
        """Create a new BatchRunner for a given model with the given
        parameters.
        Args:
            model_cls: The class of model to batch-run.
            parameters_list: A list of dictionaries of parameter sets.
                The model will be run with dictionary of parameters.
                For example, given parameters_list of
                    [{"homophily": 3, "density": 0.8, "minority_pc": 0.2},
                    {"homophily": 2, "density": 0.9, "minority_pc": 0.1},
                    {"homophily": 4, "density": 0.6, "minority_pc": 0.5}]
                3 models will be run, one for each provided set of parameters.
            fixed_parameters: Dictionary of parameters that stay same through
                all batch runs. For example, given fixed_parameters of
                    {"constant_parameter": 3},
                every instantiated model will be passed constant_parameter=3
                as a kwarg.
            iterations: The total number of times to run the model for each set
                of parameters.
            max_steps: Upper limit of steps above which each run will be halted
                if it hasn't halted on its own.
            model_reporters: The dictionary of variables to collect on each run
                at the end, with variable names mapped to a function to collect
                them. For example:
                    {"agent_count": lambda m: m.schedule.get_agent_count()}
            agent_reporters: Like model_reporters, but each variable is now
                collected at the level of each agent present in the model at
                the end of the run.
            display_progress: Display progress bar with time estimation?
        """
        self.model_cls = model_cls
        if parameters_list is None:
            parameters_list = []
        self.parameters_list = list(parameters_list)
        self.fixed_parameters = fixed_parameters or {}
        self._include_fixed = len(self.fixed_parameters.keys()) > 0
        self.iterations = iterations
        self.max_steps = max_steps

        for params in self.parameters_list:
            if list(params) != list(self.parameters_list[0]):
                msg = "parameter names in parameters_list are not equal across the list"
                raise ValueError(msg)

        self.model_reporters = model_reporters
        self.agent_reporters = agent_reporters

        if self.model_reporters:
            self.model_vars = {}

        if self.agent_reporters:
            self.agent_vars = {}

        # Make Compatible with Python 3.5
        self.datacollector_model_reporters = OrderedDict()
        self.datacollector_agent_reporters = OrderedDict()

        self.display_progress = display_progress

    def _make_model_args(self):
        """Prepare all combinations of parameter values for `run_all`
        Returns:
            Tuple with the form:
            (total_iterations, all_kwargs, all_param_values)
        """
        total_iterations = self.iterations
        all_kwargs = []
        all_param_values = []

        count = len(self.parameters_list)
        if count:
            for params in self.parameters_list:
                kwargs = params.copy()
                kwargs.update(self.fixed_parameters)
                all_kwargs.append(kwargs)
                all_param_values.append(list(params.values()))

        elif len(self.fixed_parameters):
            count = 1
            kwargs = self.fixed_parameters.copy()
            all_kwargs.append(kwargs)
            all_param_values.append(list(kwargs.values()))

        total_iterations *= count

        return total_iterations, all_kwargs, all_param_values

    def run_all(self):
        """Run the model at all parameter combinations and store results."""
        run_count = count()
        total_iterations, all_kwargs, all_param_values = self._make_model_args()

        with tqdm(total_iterations, disable=not self.display_progress) as pbar:
            for i, kwargs in enumerate(all_kwargs):
                param_values = all_param_values[i]
                for _ in range(self.iterations):
                    self.run_iteration(kwargs, param_values, next(run_count))
                    pbar.update()

    def run_iteration(self, kwargs, param_values, run_count):
        model = self.model_cls(**kwargs)
        results = self.run_model(model)
        if param_values is not None:
            model_key = tuple(param_values) + (run_count,)
        else:
            model_key = (run_count,)

        if self.model_reporters:
            self.model_vars[model_key] = self.collect_model_vars(model)
        if self.agent_reporters:
            agent_vars = self.collect_agent_vars(model)
            for agent_id, reports in agent_vars.items():
                agent_key = model_key + (agent_id,)
                self.agent_vars[agent_key] = reports
        # Collects data from datacollector object in model
        if results is not None:
            if results.model_reporters is not None:
                self.datacollector_model_reporters[
                    model_key
                ] = results.get_model_vars_dataframe()
            if results.agent_reporters is not None:
                self.datacollector_agent_reporters[
                    model_key
                ] = results.get_agent_vars_dataframe()

        return (
            getattr(self, "model_vars", None),
            getattr(self, "agent_vars", None),
            getattr(self, "datacollector_model_reporters", None),
            getattr(self, "datacollector_agent_reporters", None),
        )

    def run_model(self, model):
        """Run a model object to completion, or until reaching max steps.
        If your model runs in a non-standard way, this is the method to modify
        in your subclass.
        """
        while model.running and model.schedule.steps < self.max_steps:
            model.step()

        if hasattr(model, "datacollector"):
            return model.datacollector
        else:
            return None

    def collect_model_vars(self, model):
        """Run reporters and collect model-level variables."""
        model_vars = OrderedDict()
        for var, reporter in self.model_reporters.items():
            model_vars[var] = reporter(model)

        return model_vars

    def collect_agent_vars(self, model):
        """Run reporters and collect agent-level variables."""
        agent_vars = OrderedDict()
        for agent in model.schedule._agents.values():
            agent_record = OrderedDict()
            for var, reporter in self.agent_reporters.items():
                agent_record[var] = getattr(agent, reporter)
            agent_vars[agent.unique_id] = agent_record
        return agent_vars

    def get_model_vars_dataframe(self):
        """Generate a pandas DataFrame from the model-level variables
        collected.
        """

        return self._prepare_report_table(self.model_vars)

    def get_agent_vars_dataframe(self):
        """Generate a pandas DataFrame from the agent-level variables
        collected.
        """

        return self._prepare_report_table(self.agent_vars, extra_cols=["AgentId"])

    def get_collector_model(self):
        """
        Passes pandas dataframes from datacollector module in dictionary format of model reporters
        :return: dict {(Param1, Param2,...,iteration): <DataCollector Pandas DataFrame>}
        """

        return self.datacollector_model_reporters

    def get_collector_agents(self):
        """
        Passes pandas dataframes from datacollector module in dictionary format of agent reporters
        :return: dict {(Param1, Param2,...,iteration): <DataCollector Pandas DataFrame>}
        """
        return self.datacollector_agent_reporters

    def _prepare_report_table(self, vars_dict, extra_cols=None):
        """
        Creates a dataframe from collected records and sorts it using 'Run'
        column as a key.
        """
        extra_cols = ["Run"] + (extra_cols or [])
        index_cols = []
        if self.parameters_list:
            index_cols = list(self.parameters_list[0].keys())
        index_cols += extra_cols

        records = []
        for param_key, values in vars_dict.items():
            record = dict(zip(index_cols, param_key))
            record.update(values)
            records.append(record)

        df = pd.DataFrame(records)
        rest_cols = set(df.columns) - set(index_cols)
        ordered = df[index_cols + list(sorted(rest_cols))]
        ordered.sort_values(by="Run", inplace=True)
        if self._include_fixed:
            for param in self.fixed_parameters.keys():
                val = self.fixed_parameters[param]

                # avoid error when val is an iterable
                vallist = [val for i in range(ordered.shape[0])]
                ordered[param] = vallist
        return ordered


class ParameterProduct:
    def __init__(self, variable_parameters):
        self.param_names, self.param_lists = zip(
            *(copy.deepcopy(variable_parameters)).items()
        )
        self._product = product(*self.param_lists)

    def __iter__(self):
        return self

    def __next__(self):
        return dict(zip(self.param_names, next(self._product)))


# Roughly inspired by sklearn.model_selection.ParameterSampler.  Does not handle
# distributions, only lists.
class ParameterSampler:
    def __init__(self, parameter_lists, n, random_state=None):
        self.param_names, self.param_lists = zip(
            *(copy.deepcopy(parameter_lists)).items()
        )
        self.n = n
        if random_state is None:
            self.random_state = random.Random()
        elif isinstance(random_state, int):
            self.random_state = random.Random(random_state)
        else:
            self.random_state = random_state
        self.count = 0

    def __iter__(self):
        return self

    def __next__(self):
        self.count += 1
        if self.count <= self.n:
            return dict(
                zip(
                    self.param_names,
                    [self.random_state.choice(p_list) for p_list in self.param_lists],
                )
            )
        raise StopIteration()


class BatchRunner(FixedBatchRunner):
    """DEPRECATION WARNING: BatchRunner Class has been replaced batch_run function
    This class is instantiated with a model class, and model parameters
    associated with one or more values. It is also instantiated with model and
    agent-level reporters, dictionaries mapping a variable name to a function
    which collects some data from the model or its agents at the end of the run
    and stores it.
    Note that by default, the reporters only collect data at the *end* of the
    run. To get step by step data, simply have a reporter store the model's
    entire DataCollector object.
    """

    def __init__(
        self,
        model_cls,
        variable_parameters=None,
        fixed_parameters=None,
        iterations=1,
        max_steps=1000,
        model_reporters=None,
        agent_reporters=None,
        display_progress=True,
    ):
        """Create a new BatchRunner for a given model with the given
        parameters.
        Args:
            model_cls: The class of model to batch-run.
            variable_parameters: Dictionary of parameters to lists of values.
                The model will be run with every combo of these parameters.
                For example, given variable_parameters of
                    {"param_1": range(5),
                     "param_2": [1, 5, 10]}
                models will be run with {param_1=1, param_2=1},
                    {param_1=2, param_2=1}, ..., {param_1=4, param_2=10}.
            fixed_parameters: Dictionary of parameters that stay same through
                all batch runs. For example, given fixed_parameters of
                    {"constant_parameter": 3},
                every instantiated model will be passed constant_parameter=3
                as a kwarg.
            iterations: The total number of times to run the model for each
                combination of parameters.
            max_steps: Upper limit of steps above which each run will be halted
                if it hasn't halted on its own.
            model_reporters: The dictionary of variables to collect on each run
                at the end, with variable names mapped to a function to collect
                them. For example:
                    {"agent_count": lambda m: m.schedule.get_agent_count()}
            agent_reporters: Like model_reporters, but each variable is now
                collected at the level of each agent present in the model at
                the end of the run.
            display_progress: Display progress bar with time estimation?
        """
        warn(
            "BatchRunner class has been replaced by batch_run function. Please see documentation.",
            DeprecationWarning,
            2,
        )
        if variable_parameters is None:
            super().__init__(
                model_cls,
                variable_parameters,
                fixed_parameters,
                iterations,
                max_steps,
                model_reporters,
                agent_reporters,
                display_progress,
            )
        else:
            super().__init__(
                model_cls,
                ParameterProduct(variable_parameters),
                fixed_parameters,
                iterations,
                max_steps,
                model_reporters,
                agent_reporters,
                display_progress,
            )


class BatchRunnerMP(BatchRunner):  # pragma: no cover
    """DEPRECATION WARNING: BatchRunner class has been replaced by batch_run
    Child class of BatchRunner, extended with multiprocessing support."""

    def __init__(self, model_cls, nr_processes=None, **kwargs):
        """Create a new BatchRunnerMP for a given model with the given
        parameters.
        model_cls: The class of model to batch-run.
        nr_processes: int
                      the number of separate processes the BatchRunner
                      should start, all running in parallel.
        kwargs: the kwargs required for the parent BatchRunner class
        """
        warn(
            "BatchRunnerMP class has been replaced by batch_run function. Please see documentation.",
            DeprecationWarning,
            2,
        )
        if nr_processes is None:
            # identify the number of processors available on users machine
            available_processors = cpu_count()
            self.processes = available_processors
            print(f"BatchRunner MP will use {self.processes} processors.")
        else:
            self.processes = nr_processes

        super().__init__(model_cls, **kwargs)
        self.pool = Pool(self.processes)

    def _make_model_args_mp(self):
        """Prepare all combinations of parameter values for `run_all`
        Due to multiprocessing requirements of @StaticMethod takes different input, hence the similar function
        Returns:
            List of list with the form:
            [[model_object, dictionary_of_kwargs, max_steps, iterations]]
        """
        total_iterations = self.iterations
        all_kwargs = []

        count = len(self.parameters_list)
        if count:
            for params in self.parameters_list:
                kwargs = params.copy()
                kwargs.update(self.fixed_parameters)
                # run each iterations specific number of times
                for iter in range(self.iterations):
                    kwargs_repeated = kwargs.copy()
                    all_kwargs.append(
                        [self.model_cls, kwargs_repeated, self.max_steps, iter]
                    )

        elif len(self.fixed_parameters):
            count = 1
            kwargs = self.fixed_parameters.copy()
            all_kwargs.append(kwargs)

        total_iterations *= count

        return all_kwargs, total_iterations

    @staticmethod
    def _run_wrappermp(iter_args):
        """
        Based on requirement of Python multiprocessing requires @staticmethod decorator;
        this is primarily to ensure functionality on Windows OS and does not impact MAC or Linux distros
        :param iter_args: List of arguments for model run
            iter_args[0] = model object
            iter_args[1] = key word arguments needed for model object
            iter_args[2] = maximum number of steps for model
            iter_args[3] = number of time to run model for stochastic/random variation with same parameters
        :return:
            tuple of param values which serves as a unique key for model results
            model object
        """

        model_i = iter_args[0]
        kwargs = iter_args[1]
        max_steps = iter_args[2]
        iteration = iter_args[3]

        # instantiate version of model with correct parameters
        model = model_i(**kwargs)
        while model.running and model.schedule.steps < max_steps:
            model.step()

        # add iteration number to dictionary to make unique_key
        kwargs["iteration"] = iteration

        # convert kwargs dict to tuple to  make consistent
        param_values = tuple(kwargs.values())

        return param_values, model

    def _result_prep_mp(self, results):
        """
        Helper Function
        :param results: Takes results dictionary from Processpool and single processor debug run and fixes format to
        make compatible with BatchRunner Output
        :updates model_vars and agents_vars so consistent across all batchrunner
        """
        # Take results and convert to dictionary so dataframe can be called
        for model_key, model in results.items():
            if self.model_reporters:
                self.model_vars[model_key] = self.collect_model_vars(model)
            if self.agent_reporters:
                agent_vars = self.collect_agent_vars(model)
                for agent_id, reports in agent_vars.items():
                    agent_key = model_key + (agent_id,)
                    self.agent_vars[agent_key] = reports
            if hasattr(model, "datacollector"):
                if model.datacollector.model_reporters is not None:
                    self.datacollector_model_reporters[
                        model_key
                    ] = model.datacollector.get_model_vars_dataframe()
                if model.datacollector.agent_reporters is not None:
                    self.datacollector_agent_reporters[
                        model_key
                    ] = model.datacollector.get_agent_vars_dataframe()

        # Make results consistent
        if len(self.datacollector_model_reporters.keys()) == 0:
            self.datacollector_model_reporters = None
        if len(self.datacollector_agent_reporters.keys()) == 0:
            self.datacollector_agent_reporters = None

    def run_all(self):
        """
        Run the model at all parameter combinations and store results,
        overrides run_all from BatchRunner.
        """

        run_iter_args, total_iterations = self._make_model_args_mp()
        # register the process pool and init a queue
        # store results in ordered dictionary
        results = {}

        if self.processes > 1:
            with tqdm(total_iterations, disable=not self.display_progress) as pbar:
                for params, model in self.pool.imap_unordered(
                    self._run_wrappermp, run_iter_args
                ):
                    results[params] = model
                    pbar.update()

                self._result_prep_mp(results)
        # For debugging model due to difficulty of getting errors during multiprocessing
        else:
            for run in run_iter_args:
                params, model_data = self._run_wrappermp(run)
                results[params] = model_data

            self._result_prep_mp(results)

        # Close multi-processing
        self.pool.close()

        return (
            getattr(self, "model_vars", None),
            getattr(self, "agent_vars", None),
            getattr(self, "datacollector_model_reporters", None),
            getattr(self, "datacollector_agent_reporters", None),
        )


# In[3]:


import mesa
import random
from collections import defaultdict
from mesa import batchrunner
import numpy as np
import math
from mesa import time
import pandas as pd

class MarketBuyer(mesa.Agent):
    """A buyer with fixed price for a product"""

    def __init__(self, unique_id, model):
        super().__init__(unique_id, model)
        self.price = random.randint(0,15)  # initializes the buyer price
        self.surplus = 0  # this will record the agents surplus, this will be what will be added up on when the surplus is recorded
        self.trade = False  # this will record if the agent has just gone through the trade
        self.selected = None
        self.round = 1
        self.tempSurplus = 0
        self.index = (int)(self.unique_id/2)
        self.distribution = 0
        self.sumoftopA = 0
        self.sumofbotA = 0
        self.sumoftopTable = []
        self.botFormula = 0
        self.move = 0
        self.averagePrice = None
        self.pastTraders = []
        self.NValue = 0
        self.indicator = 0
        self.stored = None
        self.NValLagged = 1
        self.recordSurplus = 0
        self.id = self

    def step(self):
        self.tempSurplus = 0
        self.sumoftopTable = []
        self.botFormula = 0
        self.distribution = []
        self.averagePrice = None
        self.roundLagged = self.round - 1
        self.recordSurplus = 0

        if (self.move != 0):
            self.trade = False
            for value in (connectionListB[self.unique_id]): # table with sum of trades PER each seller
                self.sumoftopTable.append(attractionList[self.index][value.index][self.round - 1])
            for topA in self.sumoftopTable: # table with bottom equation done so it's plug & chug
                self.botFormula += (math.e**(lamValue*topA))
            for topA in self.sumoftopTable:
                preventNan = math.e**(lamValue*topA)/self.botFormula
                if math.isnan(preventNan) == True:
                    preventNan = 1
                self.distribution.append(preventNan) # this is the equation we all know and love"""
            # and this is the probability weighted choice
            other_seller = self.random.choices(connectionListB[self.unique_id], weights=self.distribution, k=1)
            print("Buyer " + str(self.unique_id) + ". Selected seller " + str(other_seller[0].unique_id))
            self.selected = other_seller[0]
            if (other_seller[0].selected != None):
                if (self.trade == False and other_seller[0].trade == False):
                    if (other_seller[0].selected.unique_id == self.unique_id):
                        print("unique id" + str(other_seller[0].selected.unique_id))
                        print("I am buyer " + str(self.unique_id) + " and I picked seller " + str(other_seller[0].unique_id) + "! My price is $" + str(
                            self.price) + " and the seller was $" + str(other_seller[0].price) + ".")
                        self.NValLagged = self.NValue
                        self.NValue = pValue * (1-kapValue) * self.NValLagged + 1
                        if (self.price > other_seller[0].price):
                            self.stored = other_seller[0]
                            if (other_seller[0] not in self.pastTraders):
                                self.pastTraders.append(other_seller[0])
                            if (other_seller[0] is self.stored):
                                self.indicator = 1
                            else:
                                self.indicator = 0
                            self.averagePrice = (self.price + other_seller[0].price)/2
                            self.surplus += (self.price - other_seller[0].price)/2
                            other_seller[0].surplus += (self.price - other_seller[0].price)/2
                            self.tempSurplus += (self.price - other_seller[0].price)/2
                            self.recordSurplus = (self.price + other_seller[0].price)/2
                            other_seller[0].recordSurplus = (self.price - other_seller[0].price)/2
                            print("Woohoo! We got the trade off! I am buyer " + str(self.unique_id) + ", and my surplus is $" + str(self.surplus))
                            print("tempSurplus for round is " +str(self.tempSurplus))
                            self.trade = True
                            other_seller[0].trade = True
                            attractionList[self.index, other_seller[0].index, self.round] = ((pValue * self.NValLagged * attractionList[self.index, other_seller[0].index, self.round - 1]) + ((dValue + (1-dValue)*self.indicator) * self.tempSurplus))/self.NValue
                            print("calculate" +str((dValue + (1-dValue)*self.indicator) * self.tempSurplus))
                            print("prevAttract" +str(attractionList[self.index, other_seller[0].index, self.round - 1]))
                            print("attraction" +str(attractionList[self.index, other_seller[0].index, self.round]))
                            print("NVal" +str(self.NValue))
                            print("NValLagged" +str(self.NValLagged))
            if (len(self.pastTraders) > 0):                                                                            
                for seller in self.pastTraders:
                    if attractionList[self.index, seller.index, self.round] != 1:
                        pass
                    else:
                        attractionList[self.index, seller.index, self.round] = ((pValue * self.NValLagged * attractionList[self.index, seller.index, self.round - 1]) + (dValue) * ((self.price - seller.price)/2))/self.NValue
            self.round+=1
            self.move+=1
        else:
            try:
                self.averagePrice = None
                self.trade = False
                self.indicator = 0
                other_seller = self.random.choice(connectionListB[self.unique_id])
                print("Buyer " + str(self.unique_id) + ". Selected seller " + str(other_seller.unique_id))
                self.selected = other_seller
                if (other_seller.selected != None):
                    if (self.trade == False and other_seller.trade == False):
                        if (other_seller.selected.unique_id == self.unique_id):
                            print("unique id" +str(other_seller.selected.unique_id))
                            print("I am buyer " + str(self.unique_id) + " and I picked seller " + str(other_seller.unique_id) + "! My price is $" + str(self.price) + " and the seller was $" + str(other_seller.price) + ".")
                            self.NValLagged = self.NValue
                            self.NValue = pValue * (1-kapValue) * self.NValLagged + 1
                            if (self.price > other_seller.price):
                                self.stored = other_seller
                                self.pastTraders.append(other_seller)
                                self.averagePrice = (self.price + other_seller.price)/2
                                self.surplus += (self.price - other_seller.price)/2
                                other_seller.surplus += (self.price - other_seller.price)/2
                                self.tempSurplus += (self.price - other_seller.price)/2
                                self.recordSurplus = (self.price - other_seller.price)/2
                                other_seller.recordSurplus = (self.price + other_seller.price)/2
                                print("Woohoo! We got the trade off! I am buyer " + str(self.unique_id) + ", and my surplus is $" + str(self.surplus))
                                print("tempSurplus for round is " +str(self.tempSurplus))
                                self.trade = True
                                other_seller.trade = True
                                self.NValue = pValue * (1-kapValue) * self.NValLagged + 1 
                                attractionList[self.index, other_seller.index, self.round] = ((pValue * self.NValLagged * attractionList[self.index, other_seller.index, self.round - 1]) + (dValue * self.tempSurplus))/self.NValue
                                print(self.NValue)
                                print("attraction" + str(attractionList[self.index, other_seller.index, self.round]))
                self.round+=1
                self.move+=1
            except IndexError:
                pass
            
        def advance(self):
            pass
        
class MarketSeller(mesa.Agent):
    """A seller with a price for a product."""
    
    def __init__(self, unique_id, model):
        super().__init__(unique_id, model)
        self.price = random.randint(0,15) ## defines the price of the product
        self.surplus = 0 ## records the surplus of the agent
        self.trade = False 
        self.selected = None
        self.tempSurplus = 0
        self.round = 1
        self.index = (int) (self.unique_id / 2)
        self.distribution = []
        self.botFormula = 0
        self.sumoftopTable = []
        self.botFormula = 0
        self.move = 0
        self.averagePrice = None
        self.NValue = 0
        self.pastTraders = []
        self.indicator = 0
        self.NValLagged = 1      
        self.stored = None
        self.recordSurplus = 0
        self.id = self
        
    def step(self):
        self.tempSurplus = 0
        self.botFormula = 0
        self.distribution = []
        self.averagePrice = None
        self.sumoftopTable = []
        self.summation = np.sum(attractionList, axis = 2)
        self.recordSurplus = 0
        if (self.move != 0):
            self.trade = False
            for value in (connectionListS[self.unique_id]):
                self.sumoftopTable.append(attractionList[value.index][self.index][self.round - 1]) ## table with sum of trades PER each buyer
            for topA in self.sumoftopTable:
                self.botFormula += (math.e**(lamValue*topA)) ## table with bottom equation done so it's plug & chug
            for topA in self.sumoftopTable:
                preventNan = math.e**(lamValue*topA)/self.botFormula
                if math.isnan(preventNan) == True:
                    preventNan = 1
                self.distribution.append(preventNan) ## this is the equation we all know and love
            other_buyer = self.random.choices(connectionListS[self.unique_id], weights=self.distribution, k=1) ## and this is the probability weighted choic
            print("Seller " + str(self.unique_id) + ". Selected buyer " + str(other_buyer[0].unique_id))
            self.selected = other_buyer[0]
            self.NValLagged = self.NValue
            self.NValue = (pValue * (1-kapValue) * self.NValLagged) + 1
            if (other_buyer[0].selected != None):
                if (self.trade == False and other_buyer[0].trade == False):
                    if (other_buyer[0].selected.unique_id == self.unique_id):
                        print("unique id" +str(other_buyer[0].selected.unique_id))
                        print("I am seller " + str(self.unique_id) + " and I picked buyer " + str(other_buyer[0].unique_id) + "! My price is $" + str(self.price) + " and the buyer was $" + str(other_buyer[0].price) + ".")
                        if (other_buyer[0].price > self.price):
                            self.stored = other_buyer[0]
                            if (other_buyer[0] not in self.pastTraders):
                                self.pastTraders.append(other_buyer[0])
                            if other_buyer[0] == self.stored:
                                self.indicator = 1 
                            else:
                                self.indicator = 0
                            self.trade = True
                            self.averagePrice = (other_buyer[0].price + self.price)/2
                            self.surplus += (other_buyer[0].price - self.price)/2
                            self.tempSurplus += (other_buyer[0].price - self.price)/2
                            self.recordSurplus = (other_buyer[0].price - self.price)/2
                            other_buyer[0].recordSurplus = (other_buyer[0].price + self.price)/2
                            other_buyer[0].surplus += (other_buyer[0].price - self.price)/2
                            print("Woohoo! We got the trade off! I am seller " + str(self.unique_id) + ", and my surplus is $" + str(self.surplus))
                            print("tempSurplus for round is " +str(self.tempSurplus))
                            attractionList[other_buyer[0].index, self.index, self.round] = ((pValue * self.NValLagged * attractionList[other_buyer[0].index, self.index, self.round - 1]) + ((dValue + (1-dValue)*self.indicator) * self.tempSurplus))/self.NValue
                            print("calculate" +str((dValue + (1-dValue)*self.indicator) * self.tempSurplus))
                            print("prevAttract" +str(attractionList[other_buyer[0].index, self.index, self.round - 1]))
                            print("attraction " +str(attractionList[other_buyer[0].index, self.index, self.round]))
                            print("NVal" +str(self.NValue))
                            print("NValLagged" +str(self.NValLagged))
            if (len(self.pastTraders)> 0):                                
                for buyer in self.pastTraders:
                    if attractionList[buyer.index, self.index, self.round] != 1:
                        pass
                    else:
                        attractionList[buyer.index, self.index, self.round] = ((pValue * self.NValLagged * attractionList[buyer.index, self.index, self.round - 1]) + ((dValue) * ((buyer.price - self.price)/2)))/self.NValue
            self.round+=1
            self.move+=1
        else:
            try:
                self.averagePrice = None
                self.trade = False
                other_buyer = self.random.choice(connectionListS[self.unique_id])
                print("Seller " + str(self.unique_id) + ". Selected buyer " + str(other_buyer.unique_id))
                self.selected = other_buyer
                self.NValue = pValue * (1-kapValue) * self.NValLagged + 1 
                if (other_buyer.selected != None):
                    if (self.trade == False and other_buyer.trade == False):
                        if (other_buyer.selected.unique_id == self.unique_id):
                            print("unique id" +str(other_buyer.selected.unique_id))
                            print("I am seller " + str(self.unique_id) + " and I picked buyer " + str(other_buyer.unique_id) + "! My price is $" + str(self.price) + " and the buyer was $" + str(other_buyer.price) + ".")
                            if (other_buyer.price > self.price):
                                self.stored = other_buyer
                                self.averagePrice = (other_buyer.price + self.price)/2
                                self.surplus += (other_buyer.price - self.price)/2
                                other_buyer.surplus += (other_buyer.price - self.price)/2
                                self.tempSurplus += (other_buyer.price - self.price)/2
                                self.recordSurplus = (other_buyer.price - self.price)/2
                                other_buyer.recordSurplus = (other_buyer.price + self.price)/2
                                print("Woohoo! We got the trade off! I am buyer " + str(self.unique_id) + ", and my surplus is $" + str(self.surplus))
                                print("tempSurplus for round is " +str(self.tempSurplus))
                                self.trade = True
                                attractionList[other_buyer.index, self.index, self.round] = ((pValue * self.NValLagged * attractionList[other_buyer.index, self.index, self.round - 1]) + (dValue * self.tempSurplus))/self.NValue
                                print("attraction" +str(attractionList[other_buyer.index, self.index, self.round]))
                                self.pastTraders.append(other_buyer)
                self.round+=1
                self.move+=1
            except IndexError:
                pass
        
    def advance(self):
        pass

def compute_surplus(model):
    agent_surpluses = 0
    for agent in model.schedule.agents:
        agent_surpluses += (agent.tempSurplus * 2)
    return agent_surpluses

def compute_trades(model):
    agent_trades = 0
    for agent in model.schedule.agents:
        if agent.tempSurplus != 0 and agent.trade == True:
            agent_trades += 1
    return agent_trades
    
class MarketModelThree(mesa.Model): ## new and improved :))! 
    """A model with some number of agents."""
    global valueSurplus
    global connectionListB
    global percentage_chance
    global sellerIndices
    global tradeList
    global buyerIndices
    global lambdaVal
    global connectionListS
    global surplusList
    global lamValue 
    global kapValue
    global dValue
    global pValue 
    sellerIndices = []
    connectionListB = {}
    percentage_chance = .33
    connectionListS = {}
    buyerIndices = []
    surplusList = []
    kapValue = 1
    lamValue = .4
    dValue = 0
    pValue = 1
    def __init__(self, B, S, seed):
        super().__init__(seed=seed)
        self.num_buyers = B
        self.num_sellers = S
        self.num_agents = (B + S)
        self.schedule = mesa.time.SimultaneousActivation(self)
        global attractionList
        attractionList = np.ones((50,50,3003))
        for i in range(self.num_agents * 2):
            if (i % 2 == 0 and self.num_buyers > 0):
                a = MarketBuyer(i, self) ## in this code, split the agents into two groups, buyers or sellers for their roles.
                self.schedule.add(a)
                buyerIndices.append(a)
                connectionListB[a.unique_id] = []
                self.num_buyers -= 1
            elif self.num_sellers > 0:
                b = MarketSeller(i, self)
                self.schedule.add(b)
                sellerIndices.append(b)
                connectionListS[b.unique_id] = []
                self.num_sellers -= 1
        
        for key in connectionListB:     
            for j in sellerIndices:
                if random.random() < percentage_chance:
                    connectionListB[key].append(j)
                    
        for key in connectionListS:
            for j in buyerIndices:
                if random.random() < percentage_chance:
                    connectionListS[key].append(j)
        
        self.datacollector = DataCollector(
            model_reporters={"compute_surplus": compute_surplus, "compute_trades": compute_trades}, agent_reporters={"averagePrice": "averagePrice", "price": "price", "recordSurplus": "recordSurplus", "selected": "selected", "id": "id"}
        )
        self.running = True
        self.datacollector.collect(self)
    def step(self):
        """Advance the model by one step."""
        for agent in self.schedule.agents:
            agent.selected = None
        self.schedule.step()
        self.datacollector.collect(self)
        print("--------------------------------------NEW ROUND------------------------------------------------------------------")


# In[4]:


import mesa
import random
from collections import defaultdict
from mesa import batchrunner
from mesa.model import Model
import numpy as np
import math
from mesa import time
import pandas as pd

params = {"B": 50, "S":50, "seed":2}

results = batch_run(
    MarketModelThree,
    parameters=params,
    iterations=1,
    max_steps=3000,
    number_processes=1,
    data_collection_period=1,
    display_progress=True,
)


# In[6]:


import pandas as pd 
import matplotlib as mpl
import matplotlib.pyplot as plt
import numpy as np
import termcolor
from termcolor import colored
import math
import networkx as nx
results_df = pd.DataFrame(results)
print(results_df.keys())
test = results_df.Step.values
pricetest = results_df.averagePrice.values
prices = results_df.price.values
agentIDs = results_df.AgentID.values
surplusX = results_df.compute_surplus.values
trades = results_df.compute_trades.values
selected = results_df.selected.values
recordSurplus = results_df.recordSurplus.values
idz = results_df.id.values
plt.rcParams.update({'font.size': 22})
plt.subplot(3, 2, 2)
plt.ylim([0,18])
plt.scatter(x=test, y=pricetest, c='DarkBlue')
plt.title("Average Price per Trade per Round")
plt.xlabel("Step")
plt.ylabel("Average Price of Trades")
agentNum = 100
from collections import Counter
import pandas
x=prices
x=x[0:agentNum]

print("x" + str(x))
y = agentIDs
y = y[0:agentNum]
sellerval = x
buyerval = x
buyerindices = y
sellerindices = y
selectednew = selected[-agentNum:]

sellerval = sellerval[1::2]
buyerval = buyerval[::2]
sellerval.sort()
buyerval[::-1].sort()
newbuyerval = buyerval
newsellerval = sellerval

print("buyerval " +str(buyerval))
print("sellerval " +str(sellerval))
surpluslist = buyerval - sellerval
meanpricelist = (buyerval + sellerval)/2
print("surpluslist is" +str(surpluslist))
print("values are" +str(meanpricelist))
meanpricelist2 = list()
surplus = 0
quantityTrade = 0
count = 0
chunked_list = list()
meanValue = 0
tempList = []
meanpricelist = meanpricelist.tolist()
tempListZ = []
stepcondense = []
tempListG = []
compPrice = 0

def variance(data, ddof=0):
    n = len(data)
    mean = sum(data) / n
    return sum((x - mean) ** 2 for x in data) / (n - ddof)

def stdev(data):
    var = variance(data)
    std_dev = math.sqrt(var)
    return std_dev

for i in surpluslist:
    if i >= 0:
        surplus += i
        quantityTrade += 1
        
print("surpluslist" +str(surpluslist))
for i in range(0, len(surpluslist)):
    if surpluslist[i] < 0:
        compPrice = meanpricelist[i - 1]
        print(compPrice)
        break
    
for i in range(0, len(test), agentNum):
    stepcondense.append(test[i])

for i in range(0, len(pricetest), agentNum):
    tempList = pricetest[i:i+agentNum]
    tempListZ = []
    for i in range(0, len(tempList)):
        if math.isnan(tempList[i]) != True:
            tempListZ.append(tempList[i])
            tempListG = [item for item in tempListZ if not (math.isnan(item)) == True]
    if (len(tempListG) == 0):
        chunked_list.append(0)
    else:
        chunked_list.append(stdev(tempListG))

for i in meanpricelist:
    count+=1
    if count <= quantityTrade:
        meanpricelist2.append(i)
    
print ('\033[0;1m')
print ("Surplus is: " + str(surplus))
print("Competitive quantity traded is: " + str(quantityTrade))  
print("Standard Deviation is " + str(stdev(meanpricelist2)))
print("Competitive price is " +str(compPrice))

plt.subplot(3,2,4)
plt.plot(test, surplusX)
plt.axhline(y=surplus, c="red")
plt.title("Surplus Per Round")
plt.xlabel("Step / Round")
plt.ylabel("Surplus")
plt.ylim(0,surplus+5)

buyerunique = np.unique(buyerval)
sellerunique = np.unique(sellerval)
unique, counts = np.unique(buyerval, return_counts = True)
x=np.asarray((unique,counts))
uniqueS, countsS = np.unique(sellerval, return_counts = True)
z = np.asarray((uniqueS,countsS))
g = np.delete(x, (0), axis=0)
m = np.delete(z, (0), axis=0)
g = np.flip(g)
g=np.insert(g, 0, 0)
m=np.insert(m, 0, 0)
g=g.flatten()
m=m.flatten()

for i in range(len(g)):
    if i != 0:
        g[i] += g[i-1]
for i in range(len(m)):
    if i != 0:
        m[i] += m[i-1]

buyerunique[::-1].sort()
plt.subplot(3, 2, 1)
buyerunique = np.insert(buyerunique, 0, buyerunique[0])
sellerunique = np.insert(sellerunique, 0, sellerunique[0])
plt.plot(g, buyerunique, label="buyer", drawstyle="steps")
plt.plot(m, sellerunique, label="seller", drawstyle="steps")
plt.ylim([0,16])
plt.tight_layout()
plt.axhline(y=compPrice, c="green")
plt.title("Supply & Demand")
plt.xlabel("Cumulative Frequency")
plt.ylabel("Prices / Values")

plt.subplot(3,2,3)
plt.plot(test, trades, c="green")
plt.axhline(y=quantityTrade, c="red")
plt.ylim([0,quantityTrade+10])
plt.title("Quantity Traded Per Round")
plt.xlabel("Step")
plt.ylabel("Quantity Trades")

plt.subplot(3,2,5)
plt.plot(stepcondense, chunked_list, c="darkred")
plt.axhline(y=stdev(meanpricelist2), c="gold")
plt.title("Price Dispersion")
plt.xlabel("Step")
plt.ylabel("Std Dev")
## buyers 15-17, sellers 0-35
plt.rcParams['figure.figsize'] = [35,15]
## the steps and flats, four cases, Connection percentage, .2, .8, small vs large markets (N = 10, N = 100), 
selectionsB = {}
selectionsS = {}
newAgentIDs = agentIDs[-agentNum:]
bVal = {}
sVal = {}
idealtrade = {}
idealtradereversed = {}
finallist = np.concatenate((newbuyerval, newsellerval), axis=0)
newIDs = idz[-agentNum:]
totalValue = []
valuem = 0
print("Parameters: Lambda = " +str(lamValue)+ " phiValue = " +str(pValue)+ " deltaValue = " +str(dValue) + " kappaValue = " + str(kapValue) + " Agent Num = 100 and SR (0,15) BR (0,15), percentageChance = " +str(percentage_chance))
for i in range(0, len(selected), agentNum):
    valuem = 0
    temproundSelect = selected[i:i+agentNum]
    for j in range(0 ,len(newAgentIDs)):
        if j % 2 == 0 and temproundSelect[j] != None:
            selectionsB[newIDs[j].id.unique_id] = [newIDs[j].id.price] ## first value, unique id, second, buyer price, seller price
            selectionsB[newIDs[j].id.unique_id].append(temproundSelect[j].price)
        elif temproundSelect[j] != None:
            selectionsS[newIDs[j].id.unique_id] = [newIDs[j].id.price]
            selectionsS[newIDs[j].id.unique_id].append(temproundSelect[j].price)
            
    for x in range(0, (int) (len(newAgentIDs)/2)):
        if newbuyerval[x] >= newsellerval[x]:
            idealtrade[x] = [newbuyerval[x]]
            idealtrade[x].append(newsellerval[x])
            idealtradereversed[x] = [newsellerval[x]]
            idealtradereversed[x].append(newbuyerval[x])
                
    for k in range(0, len(idealtrade)):
        for key in selectionsB.copy():
                if idealtrade[k] == selectionsB[key]:
                    for keyX in selectionsS.copy():
                        if idealtradereversed[k] == selectionsS[keyX]:
                            selectionsS.pop(keyX)
                            selectionsB.pop(key)
                            valuem += 1
                            break
    totalValue.append(valuem)

idealtradenum = 0
plt.subplot(3,2,6)
for key in idealtrade:
        idealtradenum += 1
plt.plot(stepcondense, totalValue, c="orange")
plt.axhline(y=idealtradenum, c="purple")
plt.xlabel("Step")
plt.ylabel("Number of Pairwise Stable Trades")
plt.title("Pairwise Stable Trades per Round")


# In[ ]:




